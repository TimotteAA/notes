## io模型

通常讲解的io模型，本质上都是对`流`对象的操作，（对于非底层的开发者）通常流有以下几种：

1. 可以进行io操作的内核对象
2. 文件、管道、套接字socket
3. 流的入口：文件描述符(fd)



### io模型

在常见的io模型，大致以下几种分类方法：

1. 同步

   1.1 阻塞式

   1.2 非阻塞式

   1.3 io多路复用（select、epoll）

2. 异步



#### 阻塞式

阻塞式io模型，打个比方：

![image-20240310142518364](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240310142518364.png)

你在家里等待快递，如果快递一直没来，则你啥也不做，直到快递来了。

#### 非阻塞式+忙轮询

![image-20240310142557485](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240310142557485.png)

相比阻塞式，非阻塞式中你需要定时的去打电话问一下跑男，到底到哪了



从上面两个图可以看到，阻塞式的优点在于，即使快递没到，也不会消耗时间去进行轮询（cpu在用）。

而阻塞式的缺点在于：

![image-20240310142857705](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240310142857705.png)

如果同一时刻有多个脚男到了，只能一个个的处理，当然可以通过多进程的方式来解决这个问题。

如何在单进程下解决这个问题呢？


### io多路复用

#### select

![image-20240310143011625](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240310143011625.png)

搞一个快递代理select员工，当有消息到来后，通知你一下处理。没消息的时候，睡觉就行了，伪代码如下：

```go
func main() {
   	while (true) {
        if (流[]) // 阻塞式
        
        for (流 in 流[]) {
            if (流可操作) {
                处理
            }
        }
	} 
}

```

select有一个弊端：无法告知你具体哪些流来了，当有数据到来后，只能一个个的检查流，看下是不是有数据可以处理。



#### epoll

在select基础上，又推出了epoll模型：

![image-20240310143300832](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240310143300832.png)

```go
func main() {
    while (true) {
        可处理的流[] = epoll_wait(epoll_fd) // 阻塞
        
        for (流 in 可处理的流) {
            // 进行操作
        }
    }
}
```



#### epoll的简单原理

epoll是由linux操作系统提供的io多路复用功能：

1. **创建`epoll`实例**：当应用程序需要使用`epoll`进行I/O事件监控时，首先通过调用`epoll_create`函数来创建一个`epoll`实例。这个实例背后是由操作系统内核维护的，用于跟踪和管理所有注册的`文件描述符`及其对应的事件。
2. **注册文件描述符和事件**：应用程序通过`epoll_ctl`函数，将感兴趣的文件描述符及其期望监听的事件类型（例如，可读、可写等）注册到`epoll`实例中。内核会将这些注册的文件描述符存储在一个高效的数据结构中，Linux内核使用红黑树（一种自平衡的二叉查找树）来管理这些文件描述符，以支持快速的查找、插入和删除操作。
3. **等待事件发生**：应用程序调用`epoll_wait`函数等待事件的发生。在这一步骤中，操作系统内核检查红黑树中的文件描述符，以确定是否有任何注册的事件发生。如果当前没有任何事件发生，`epoll_wait`可以选择阻塞调用进程，直到有事件发生或达到指定的超时时间。
4. **事件通知**：一旦有一个或多个文件描述符上发生了注册的事件，内核将这些“活跃”的文件描述符及其对应的事件信息放入到一个就绪列表中。然后，`epoll_wait`函数返回，提供就绪列表给应用程序，使其可以据此处理发生的事件。
5. **处理事件**：应用程序根据`epoll_wait`返回的信息，执行对应的操作，如读取数据、写入数据或执行其他相应的I/O操作。



###### 一些细节点：

1. **创建`epoll`实例**：当你调用`epoll_create`时，实际上是在创建一个新的`epoll`实例。这个实例有自己的文件描述符（FD），用于后续的操作（如添加监视的文件描述符、等待事件等）。这个`epoll`实例并不是放在红黑树上的；相反，它本身管理着一个红黑树，用于维护所有注册到该`epoll`实例的感兴趣的文件描述符及其事件。
2. **红黑树管理FD**：对于每个`epoll`实例，内核使用红黑树这种数据结构来存储和管理所有通过`epoll_ctl`注册到该实例的文件描述符和它们对应的事件。红黑树被选择是因为它在添加、删除和查找元素时都能提供对数时间复杂度的性能，这对于维护大量文件描述符是非常有效的。
3. **文件描述符（FD）和事件**：每当你通过`epoll_ctl`向`epoll`实例注册一个文件描述符时，你需要指定你对该文件描述符的哪些事件感兴趣（例如，可读、可写、连接关闭等）。这些信息（文件描述符及其对应的事件）被添加到`epoll`实例管理的红黑树中。
4. **等待事件并通知**：通过调用`epoll_wait`等待事件发生。这个调用会检查其管理的红黑树中的文件描述符，看是否有任何注册的事件发生。如果有，`epoll_wait`会收集这些活跃的事件并返回，允许应用程序相应地处理它们。