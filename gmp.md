## 内核空间和用户空间

早先学习操作系统时，总是有点疑惑：系统调用是啥？内核态是啥？用户态是啥？我们写的程序是如何实现文件的读取、访问等等。

今日特意花费时间进行一些学习。

平日在linux中开发时，通常会使用`top`命令在查看进程的内存、Cpu消耗情况：

![image-20240309102953484](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240309102953484.png)

可以看到，在上图中 cpu部分有以下几个部分：

1. `us`（用户空间耗时）cpu在用户空间耗时
2. `sy`（内核空间耗时）cpu在内核空间耗时、
3. `ni`：niceness 的缩写，CPU 消耗在 nice 进程（低优先级）的时间百分比
4. `id`：idle 的缩写，CPU 消耗在闲置进程的时间百分比，这个值越低，表示 CPU 越忙
5. `wa`：wait 的缩写，CPU 等待外部 I/O 的时间百分比，这段时间 CPU 不能干其他事，但是也没有执行运算，这个值太高就说明外部设备有问题
6. `hi`：hardware interrupt 的缩写，CPU 响应硬件中断请求的时间百分比
7. `si`：software interrupt 的缩写，CPU 响应软件中断请求的时间百分比
8. `st`：stole time 的缩写，该项指标只对虚拟机有效，表示分配给当前虚拟机的 CPU 时间之中，被同一台物理机上的其他虚拟机偷走的时间百分比

用下面的图可以解释命令在执行，内核空间与用户控件的关系：

![img](https://www.ruanyifeng.com/blogimg/asset/2016/bg2016120201-2.png)

简单说，Kernel space 是 Linux 内核的运行空间（进行内存管理、进程管理、文件系统、网络等），User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。

Kernel space 可以执行任意命令，调用系统的一切资源；User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。

> ```clike
> str = "my string" // 用户空间
> x = x + 2
> file.write(str) // 切换到内核空间
> 
> y = x + 4 // 切换回用户空间
> ```

上面代码中，第一行和第二行都是简单的赋值运算，在 User space 执行。第三行需要写入文件，就要切换到 Kernel space，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 User space。



#### 早期的操作系统

早期的操作系统是单进程的，如下图：

![image-20240309104215746](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240309104215746.png)

单进程意味着进程A、进程B、进程C只能串行一个个按顺序执行。

早期的单进程操作系统面临两个问题：

1. 单一的执行流程，计算机只能一个任务一个任务处理。

2. 进程阻塞所带来的CPU时间浪费。

既然单进程效率低，那为啥不用多进程呢？

后来操作系统就具有了**最早的并发能力：多进程并发**，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。



#### 多进程、多线程操作系统

![image-20240309111108930](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240309111108930.png)



在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。



但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。（60%在执行进程，40%在进程调度）



如何提高cpu的利用率呢？改用线程？

但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。

![image-20240309111345069](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240309111345069.png)



CPU调度时，需要切换进程、线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。



### 使用协程来提高CPU利用率

多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。

大量的进程/线程出现了新的问题

* 高内存占用

- 调度的高消耗CPU

好了，然后工程师们就发现，其实一个线程分为“内核态“线程和”用户态“线程。

一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)：



##### 一对一模型

![image-20240309111746202](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240309111746202.png)



##### 一对多模型

![image-20240309113056093](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240309113056093.png)



##### 多对多模型

![image-20240309113110605](https://typora-1316630864.cos.ap-shanghai.myqcloud.com/image-20240309113110605.png)



关于**cpu视野**的注释：

1. cpu对于执行的线程具体是内核线程还是用户线程，cpu只负责执行操作系统调度的线程

2. 用户线程的创建由线程库创建，比如pthread

3. 在一对一模型中，当创建一个用户线程时，随之也会申请创建一个内核线程。用户线程执行时，其实是操作系统调度其对应的内核线程来运行，用户线程的代码就在这个内核线程的上下文中执行。因此，从操作系统的角度来看，在调度和运行内核线程。

4. 在一对多模型中，多个用户线程共享一个内核线程。用户线程的调度完全在用户空间内部，通过线程库来管理。一个用户线程的代码执行时，实际上是在利用当前进程内的唯一内核线程执行。如果一个用户线程进行了阻塞操作，如I/O请求，它将阻塞整个进程（包括所有的用户线程），因为只有一个内核线程代表整个进程与操作系统内核交互。

5. 在多对多模型中，用户线程对应多个内核线程。用户线程的代码执行可能通过任何一个可用的内核线程来进行，这取决于线程库和操作系统调度器的具体实现和决策。这种模型可以动态地调整用户线程与内核线程之间的映射关系，以适应运行时的需求变化。

   



#### go语言的gorountine

GMP：

1. G，goroutine协程
2. M，用户线程
3. P，调度器

Go语言中的`goroutine`是一个更轻量级的执行单元，它在用户空间内实现调度，这使得`goroutine`非常高效和灵活。Go运行时包含自己的调度器，这个调度器在用户态运行，负责管理`goroutines`的执行。这种调度方式与传统的操作系统线程调度不同，因为它不直接依赖于操作系统的线程（即内核线程）进行调度，而是由Go运行时自己来管理`goroutines`之间的调度和切换。



##### gmp模型







